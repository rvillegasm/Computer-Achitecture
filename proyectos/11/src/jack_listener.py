"""
Module containing a Listener implementation for the Jack analizer.
It uses the listener generated by the ANTLR4 tool.
"""

from JackGrammarListener import JackGrammarListener
from JackGrammarParser import JackGrammarParser

class Listener(JackGrammarListener):
    """
    Class that defines the behaviour of a Grammar Listener for the Jack Compiler.

    It inherits from the default listener generated by the ANTLR4 parser/lexer generator tool,
    so it is necessary to make sure that the default listener has been generated before trying to use this class.
    """
    
    VAR_KIND_TO_VM_SEGMENT = {
                                "STATIC": "STATIC",
                                "FIELD": "THIS",
                                "ARG": "ARG",
                                "VAR": "LOCAL"
                             }

    BINARY_OPERATORS = {
                            '+': "ADD",
                            '-': "SUB",
                            '=': "EQ",
                            '<': "LT",
                            '>': "GT",
                            '&': "AND",
                            '|': "OR",
                       }

    UNARY_OPERATORS = {
                        '-': "NEG",
                        '~': "NOT"
                      }

    KEYWORD_CONSTANTS = ["true", "false", "null", "this"]

    def __init__(self, parser, vm_writer, symbol_table):
        """ Constructor. Uses a VM Writer to write vm commands to the output file. """
        self.parser = parser
        self.vm_writer = vm_writer
        self.symbol_table = symbol_table
        self.current_class = ''
        self.current_subroutine_name = ''
        self.current_subroutine_kind = ''
        self.if_index = -1
        self.while_index = -1

    def enterClassNT(self, ctx):
        # get the name of hte current class and store it
        self.current_class = ctx.getChild(1).getText()
        return super().enterClassNT(ctx)

    def enterClassVarDecNT(self, ctx):
        child_count = ctx.getChildCount()
        # get the variable kind (static | field), type and name
        var_kind = ctx.getChild(0).getText()
        var_type = ctx.getChild(1).getText()
        var_name = ctx.getChild(2).getText()

        self.symbol_table.define(var_name, var_type ,var_kind.upper())

        # if the child count is more than 4, it means that for every other 2 children there is a new identifier
        if child_count > 4:
            for i in range((child_count - 4) // 2):
                var_name_extra = ctx.getChild(2 + (i*2 + 2)).getText()
                self.symbol_table.define(var_name_extra, var_type ,var_kind.upper())

        return super().enterClassVarDecNT(ctx)
        
    def enterSubroutineDecNT(self, ctx):
        self.symbol_table.start_subroutine()

        subroutine_kind = ctx.getChild(0).getText()
        subroutine_name = ctx.getChild(2).getText()
        # store subroutine name and kind for later
        self.current_subroutine_name = subroutine_name
        self.current_subroutine_kind = subroutine_kind

        if subroutine_kind == "method":
            # tell the symbol table that the first argument is the reference to the object
            self.symbol_table.define("this", self.current_class, "ARG")
        # if the specified child is ')', then there are no arguments
        if ctx.getChild(4).getText() != '':
            # child 4 is the parameter list
            self.compileParameterList(ctx.getChild(4))
        
        # child 6 is the body
        self.compileSubroutineBody(ctx.getChild(6))
        

        return super().enterSubroutineDecNT(ctx)

    def compileParameterList(self, ctx):
        # name and type fo the first variable
        var_type = ctx.getChild(0).getText()
        var_name = ctx.getChild(1).getText()
        # define it in the symbol table
        self.symbol_table.define(var_name, var_type, "ARG")
        # repeat if there are more variable
        child_count = ctx.getChildCount()
        if child_count > 2:
            for i in range((child_count - 2) // 3):
                var_type_extra = ctx.getChild(0 + (i*3 + 3)).getText()
                var_name_extra = ctx.getChild(1 + (i*3 + 3)).getText()
                self.symbol_table.define(var_name_extra, var_type_extra, "ARG")

    def compileSubroutineBody(self, ctx):
        n_locals = 0
        while ctx.getChild(n_locals+1).getText()[:3] == "var":
            # in this case, current_child is a variable declaration 
            self.compileVarDec(ctx.getChild(n_locals+1))
            n_locals += 1

        # write the function to the output
        vm_funtion_name = "{}.{}".format(self.current_class, self.current_subroutine_name)
        num_locals = self.symbol_table.var_count("VAR")
        self.vm_writer.write_function(vm_funtion_name, num_locals)

        # check if it is a constructor or a method
        if self.current_subroutine_kind == "constructor":
            # if it is a constructor, the object is defined in the heap
            # and the reference to it is stored on the POINTER 0 segment (THIS)
            num_fields = self.symbol_table.var_count("FIELD")
            self.vm_writer.write_push("CONST", num_fields)
            self.vm_writer.write_call("Memory.alloc", 1)
            self.vm_writer.write_pop("POINTER", 0)

        elif self.current_subroutine_kind == "method":
            # if it is a method, get the reference to the object and store it in the POINTER 0 segment (THIS)
            self.vm_writer.write_push("ARG", 0)
            self.vm_writer.write_pop("POINTER", 0)

        self.compileStatements(ctx.getChild(n_locals+1))

    def compileVarDec(self, ctx):
        # get the first identifier
        var_type = ctx.getChild(1).getText()
        var_name = ctx.getChild(2).getText()
        self.symbol_table.define(var_name, var_type, "VAR")
        
        # get the rest, if any at all
        child_count = ctx.getChildCount()
        if child_count > 4:
            for i in range((child_count - 4) // 2):
                var_name_extra = ctx.getChild(2 + (i*2 + 2)).getText()
                self.symbol_table.define(var_name_extra, var_type, "VAR")

    def compileStatements(self, ctx):
        # get the number of statements
        num_statements = ctx.getChildCount()
        if num_statements > 0:
            for i in range(num_statements):
                current_statement = ctx.getChild(i)
                # check for the type of statement and pass it to it's corresponding type
                if current_statement.getText()[:3] == "let":
                    self.compileLetStatement(current_statement.getChild(0))

                elif current_statement.getText()[:2] == "if":
                    self.compileIfStatement(current_statement.getChild(0))

                elif current_statement.getText()[:5] == "while":
                    self.compileWhileStatement(current_statement.getChild(0))

                elif current_statement.getText()[:2] == "do":
                    self.compileDoStatement(current_statement.getChild(0))
                    
                elif current_statement.getText()[:6] == "return":
                    self.compileReturnStatement(current_statement.getChild(0))
        
    def compileLetStatement(self, ctx):
        var_name = ctx.getChild(1).getText()
        var_kind = self.symbol_table.kind_of(var_name)
        vm_segment = Listener.VAR_KIND_TO_VM_SEGMENT[var_kind]
        var_index = self.symbol_table.index_of(var_name)
        # if the variable was not found, raise an exception
        if var_index == None:
            raise NameError("Symbol error!: Symbol [{}] used before it was declared")
        # get the child count to know if it is an array-reffering expression or not
        child_count = ctx.getChildCount()
        # in this case it is an array
        if child_count == 8:
            # compile the expression, which will leave the value on the top of the stack
            self.compileExpression(ctx.getChild(3))
            # push the base address of the array and add it to the calculated index
            self.vm_writer.write_push(vm_segment, var_index)
            self.vm_writer.write_arithmetic("ADD")
            # store it in the temp 0 segment for now
            self.vm_writer.write_pop("TEMP", 0)
            # compile the other expression
            self.compileExpression(ctx.getChild(6))
            # push the array index onto the stack
            self.vm_writer.write_push("TEMP", 0)
            # pop the index to the pointer 0 segment, so that it can be refferenced with 'THAT'
            self.vm_writer.write_pop("POINTER", 1)
            # store the expression value on the specified index
            self.vm_writer.write_pop("THAT", 0)
        else:
            self.compileExpression(ctx.getChild(3))
            self.vm_writer.write_pop(vm_segment, var_index)

    def compileIfStatement(self, ctx):
        self.if_index += 1
        if_index = self.if_index
        # evaluate the expression and write the if-goto and goto commands
        self.compileExpression(ctx.getChild(2))
        # get the child count to know if the 'if' has an 'else' or not
        child_count = ctx.getChildCount()
        if child_count == 7:
            # in this case, there is no 'else'
            self.vm_writer.write_if("IF_TRUE{}".format(if_index))
            self.vm_writer.write_goto("IF_FALSE{}".format(if_index))
            # write the true label and compute the statements that follow
            self.vm_writer.write_label("IF_TRUE{}".format(if_index))
            self.compileStatements(ctx.getChild(5))
            self.vm_writer.write_label("IF_FALSE{}".format(if_index))

        else:
            # in this case, there is an 'else'
            self.vm_writer.write_if("IF_TRUE{}".format(if_index))
            self.vm_writer.write_goto("IF_FALSE{}".format(if_index))
            # write the true label and compute the statements that follow
            self.vm_writer.write_label("IF_TRUE{}".format(if_index))
            self.compileStatements(ctx.getChild(5))
            self.vm_writer.write_goto("END_IF{}".format(if_index))
            # write the flase label to compute the statements that follow
            self.vm_writer.write_label("IF_FALSE{}".format(if_index))
            self.compileStatements(ctx.getChild(9))
            # write the end if label to end it
            self.vm_writer.write_label("END_IF{}".format(if_index))

    def compileWhileStatement(self, ctx):
        self.while_index += 1
        while_index = self.while_index

        self.vm_writer.write_label("WHILE{}".format(while_index))
        self.compileExpression(ctx.getChild(2))
        # if the negated condition is true, get out of the loop
        self.vm_writer.write_arithmetic("NOT")
        self.vm_writer.write_if("END_WHILE{}".format(while_index))
        # evaluate the statements
        self.compileStatements(ctx.getChild(5))
        # jump back to the beggining of loop
        self.vm_writer.write_goto("WHILE{}".format(while_index))
        # go back to the beggining
        self.vm_writer.write_label("END_WHILE{}".format(while_index))

    def compileDoStatement(self, ctx):
        self.compileSubroutineCall(ctx.getChild(1))
        # pop the return value and ignore it
        self.vm_writer.write_pop("TEMP", 0)

    def compileReturnStatement(self, ctx):
        # evaluate the child count to know if there is a return value or not
        child_count = ctx.getChildCount()
        if child_count == 3:
            # evaluate the expression and leave it at the top of the stack
            self.compileExpression(ctx.getChild(1))
        else:
            # push the constant 0 to the stack
            self.vm_writer.write_push("CONST", 0)
        # write the return command
        self.vm_writer.write_return()

    def compileExpression(self, ctx):
        # get the first term
        self.compileTerm(ctx.getChild(0))
        # check the child count to know how many operations are needed
        child_count = ctx.getChildCount()
        for i in range((child_count - 1) // 2):
            self.compileTerm(ctx.getChild(i*2 + 2))
            operator = ctx.getChild(i*2 + 1).getText()
            # write the operator to the output
            if operator in Listener.BINARY_OPERATORS.keys():
                self.vm_writer.write_arithmetic(Listener.BINARY_OPERATORS[operator])
            elif operator == '*':
                self.vm_writer.write_call("Math.multiply", 2)
            elif operator == '/':
                self.vm_writer.write_call("Math.divide", 2)
                
    def compileTerm(self, ctx):
        # check for an integer constant
        if ctx.getChild(0).getText().isdigit():
            self.vm_writer.write_push("CONST", ctx.getChild(0).getText())
        # check for strings
        elif ctx.getChild(0).getText()[0] == '"':
            self.buildString(ctx.getChild(0).getText())
        # check for keyword constants
        elif ctx.getChild(0).getText() in Listener.KEYWORD_CONSTANTS:
            self.compileKeyword(ctx.getChild(0).getText())
        # check for unary operator term
        elif ctx.getChild(0).getText() in Listener.UNARY_OPERATORS.keys():
            operator = ctx.getChild(0).getText()
            self.compileTerm(ctx.getChild(1))
            self.vm_writer.write_arithmetic(Listener.UNARY_OPERATORS[operator])
        # check for (expression)
        elif ctx.getChild(0).getText() == '(':
            self.compileExpression(ctx.getChild(1))
        else:
            # check for varName[expression]
            child_count = ctx.getChildCount()
            child_count_subroutine = ctx.getChild(0).getChildCount()
            if child_count > 1 and ctx.getChild(1).getText() == '[':
                # get the name of the array
                array_name = ctx.getChild(0).getText()
                # evaluate the expression
                self.compileExpression(ctx.getChild(2))
                # get the kind and base address of the array
                array_base_address = self.symbol_table.index_of(array_name)
                array_kind = self.symbol_table.kind_of(array_name)
                vm_segment = Listener.VAR_KIND_TO_VM_SEGMENT[array_kind]
                # check for errors
                if array_base_address == None or array_kind == None: 
                    raise NameError("Symbol error!: Symbol [{}] used before it was declared")
                # push the base address and add it with the expression to get the result address
                self.vm_writer.write_push(vm_segment, array_base_address)
                self.vm_writer.write_arithmetic("ADD")
                # store the address to the that segment and then put the value on the stack again
                self.vm_writer.write_pop("POINTER", 1)
                self.vm_writer.write_push("THAT", 0)
            # check for subroutine call
            elif (child_count_subroutine > 1) and (ctx.getChild(0).getChild(1).getText() == '(' or ctx.getChild(0).getChild(1).getText() == '.'):
                self.compileSubroutineCall(ctx.getChild(0))
            # otherwhise, it is a varName
            else:
                # get the namem kind, and index
                var_name = ctx.getChild(0).getText()
                var_kind = self.symbol_table.kind_of(var_name)
                var_index = self.symbol_table.index_of(var_name)
                # check for errors
                if var_kind == None or var_index == None:
                    raise NameError("Symbol error!: Symbol [{}] used before it was declared")
                # get the vm segment and push to it
                vm_segment = Listener.VAR_KIND_TO_VM_SEGMENT[var_kind]
                self.vm_writer.write_push(vm_segment, var_index)
        
    def buildString(self, string_literal):
        # remove the quotation marks
        string = string_literal.strip('"')
        # allocate space for the string
        self.vm_writer.write_push("CONST", len(string))
        self.vm_writer.write_call("String.new", 1)
        # append every characher (unicode)
        for char in string:
            self.vm_writer.write_push("CONST", ord(char))
            self.vm_writer.write_call("String.appendChar", 2)

    def compileKeyword(self, keyword):
        # if it is the 'this' keyword, push the this pointer
        if keyword == "this":
            self.vm_writer.write_push("POINTER", 0)
        # otherway, it is either a null or a false, which are reresented by a 0
        else:
            self.vm_writer.write_push("CONST", 0)
        # but if it is a true, it is represented by a -1
        if keyword == "true":
            self.vm_writer.write_arithmetic("NOT")

    def compileSubroutineCall(self, ctx):
        n_args = 0
        if ctx.getChild(1).getText() == '(':
            subroutine_name = ctx.getChild(0).getText()
            vm_function_name = "{}.{}".format(self.current_class, subroutine_name)
            n_args += 1
            self.vm_writer.write_push("POINTER", 0)
            # get the number of arguments
            n_args += self.compileExpressionList(ctx.getChild(2))

        elif ctx.getChild(1).getText() == '.':
            subroutine_caller = ctx.getChild(0).getText()
            subroutine_name = ctx.getChild(2).getText()
            caller_type = self.symbol_table.type_of(subroutine_caller)
            # if the type isn't None, it is an object
            if caller_type != None:
                object_kind = self.symbol_table.kind_of(subroutine_caller)
                object_index = self.symbol_table.index_of(subroutine_caller)
                vm_segment = Listener.VAR_KIND_TO_VM_SEGMENT[object_kind]
                # push the object to the stack
                self.vm_writer.write_push(vm_segment, object_index)
                # write the function
                vm_function_name = "{}.{}".format(caller_type, subroutine_name)
                n_args += 1
            # else, it is a class
            else:
                vm_function_name = "{}.{}".format(subroutine_caller, subroutine_name)
            # get the number of arguments
            n_args += self.compileExpressionList(ctx.getChild(4))
        
        # write the function call
        self.vm_writer.write_call(vm_function_name, n_args)

    def compileExpressionList(self, ctx):
        # declare the number of expressions
        num_expressions = 0
        # get the child count to know how many expressions are there
        child_count = ctx.getChildCount()
        if child_count > 0:
            self.compileExpression(ctx.getChild(0))
            num_expressions += 1
            for i in range((child_count - 1) // 2):
                self.compileExpression(ctx.getChild(i*2 + 2))
                num_expressions += 1

        return num_expressions
